# -*- coding: utf-8 -*-
"""Build Your Own Redis Server.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Uk9Y19eGBnODEqWc8Z5ZUdsYlRuJQuFc

**Step 1:Serializing and Deserializing RESP Messages**
"""

def serialize_resp(message):
    if isinstance(message, str):
        return f"+{message}\r\n"
    elif isinstance(message, int):
        return f":{message}\r\n"
    elif isinstance(message, bytes):
        return f"${len(message)}\r\n{message.decode('utf-8')}\r\n"
    elif isinstance(message, list):
        return f"*{len(message)}\r\n" + ''.join([serialize_resp(item) for item in message])
    else:
        raise ValueError("Unsupported RESP message type")

def deserialize_resp(data):
    if data.startswith("+"):
        return data[1:].strip()
    elif data.startswith(":"):
        return int(data[1:].strip())
    elif data.startswith("$"):
        parts = data.split('\r\n', 1)
        length = int(parts[0][1:])
        if length == -1:
            return None
        else:
            return parts[1][:length]
    elif data.startswith("*"):
        parts = data.split('\r\n')[1:-1]
        return [deserialize_resp(part) for part in parts]
    else:
        raise ValueError("Invalid RESP data")

"""**Step 2:  Implementing Redis Lite Server**"""

import socket

def handle_command(command):
    if command[0].upper() == "PING":
        return "PONG"
    elif command[0].upper() == "ECHO":
        return command[1]

def start_redis_lite_server():
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind(('localhost', 6379))
    server_socket.listen(5)

    print("Redis Lite server is running...")

    while True:
        client_socket, address = server_socket.accept()
        print(f"Connection from {address}")

        data = client_socket.recv(1024).decode('utf-8').strip()
        if data:
            command = deserialize_resp(data)
            response = handle_command(command)
            serialized_response = serialize_resp(response)
            client_socket.send(serialized_response.encode('utf-8'))

        client_socket.close()

start_redis_lite_server()

"""**Step 3: SET and GET Commands**"""

class RedisLite:
    def __init__(self):
        self.data = {}

    def set(self, key, value):
        self.data[key] = value
        return "OK"

    def get(self, key):
        return self.data.get(key, None)

def handle_command(command):
    if command[0].upper() == "PING":
        return "PONG"
    elif command[0].upper() == "ECHO":
        return command[1]
    elif command[0].upper() == "SET":
        return redis_lite.set(command[1], command[2])
    elif command[0].upper() == "GET":
        return redis_lite.get(command[1])

"""**Step 4: Handling Multiple Concurrent Clients**"""

import threading

def handle_client(client_socket):
    data = client_socket.recv(1024).decode('utf-8').strip()
    if data:
        command = deserialize_resp(data)
        response = handle_command(command)
        serialized_response = serialize_resp(response)
        client_socket.send(serialized_response.encode('utf-8'))
    client_socket.close()

def start_redis_lite_server():
    # Same as before
    while True:
        client_socket, address = server_socket.accept()
        print(f"Connection from {address}")

        client_thread = threading.Thread(target=handle_client, args=(client_socket,))
        client_thread.start()

"""**Step 5: Expiry Options for SET Command**"""

import time

class RedisLite:
    def __init__(self):
        self.data = {}

    def set(self, key, value, expiry=None):
        if expiry:
            expiry_time = time.time() + expiry
            self.data[key] = (value, expiry_time)
        else:
            self.data[key] = (value, None)
        return "OK"

    def get(self, key):
        if key in self.data:
            value, expiry_time = self.data[key]
            if expiry_time is None or expiry_time > time.time():
                return value
            else:
                del self.data[key]  # Expired, remove from data
        return None

def handle_command(command):
    if command[0].upper() == "PING":
        return "PONG"
    elif command[0].upper() == "ECHO":
        return command[1]
    elif command[0].upper() == "SET":
        if len(command) == 4 and command[3].upper() == "EX":
            expiry = int(command[4])
            return redis_lite.set(command[1], command[2], expiry)
        else:
            return redis_lite.set(command[1], command[2])
    elif command[0].upper() == "GET":
        return redis_lite.get(command[1])

redis_lite = RedisLite()

"""**Step 6: Additional Commands**"""

class RedisLite:
    def __init__(self):
        self.data = {}

    def set(self, key, value):
        self.data[key] = value
        return "OK"

    def get(self, key):
        return self.data.get(key, None)

    def exists(self, key):
        return key in self.data

    def delete(self, *keys):
        deleted_count = 0
        for key in keys:
            if key in self.data:
                del self.data[key]
                deleted_count += 1
        return deleted_count

    def incr(self, key):
        if key in self.data:
            value = self.data[key]
            if isinstance(value, int):
                self.data[key] = value + 1
                return value + 1
            else:
                raise ValueError("Cannot increment non-integer value")
        else:
            self.data[key] = 1
            return 1

    def decr(self, key):
        if key in self.data:
            value = self.data[key]
            if isinstance(value, int):
                self.data[key] = value - 1
                return value - 1
            else:
                raise ValueError("Cannot decrement non-integer value")
        else:
            self.data[key] = -1
            return -1

    def lpush(self, key, *values):
        if key not in self.data:
            self.data[key] = []
        self.data[key] = list(values) + self.data[key]
        return len(self.data[key])

    def rpush(self, key, *values):
        if key not in self.data:
            self.data[key] = []
        self.data[key].extend(values)
        return len(self.data[key])

def handle_command(command):
    if command[0].upper() == "PING":
        return "PONG"
    elif command[0].upper() == "ECHO":
        return command[1]
    elif command[0].upper() == "SET":
        return redis_lite.set(command[1], command[2])
    elif command[0].upper() == "GET":
        return redis_lite.get(command[1])
    elif command[0].upper() == "EXISTS":
        return redis_lite.exists(command[1])
    elif command[0].upper() == "DEL":
        return redis_lite.delete(*command[1:])
    elif command[0].upper() == "INCR":
        return redis_lite.incr(command[1])
    elif command[0].upper() == "DECR":
        return redis_lite.decr(command[1])
    elif command[0].upper() == "LPUSH":
        return redis_lite.lpush(command[1], *command[2:])
    elif command[0].upper() == "RPUSH":
        return redis_lite.rpush(command[1], *command[2:])

redis_lite = RedisLite()

"""**Step 7: Performance Testing**"""

# To run performance test
def run_performance_test():
    # Initialize RedisLite server
    redis_lite = RedisLite()

    # Start RedisLite server (assuming it's already implemented)
    start_redis_lite_server()

    # Use redis-benchmark to test performance
    # Example: redis-benchmark -t set,get -n 100000 -q

